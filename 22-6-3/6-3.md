# 1.C++

## 1.1 基于作用域的thread管理类
```cpp
int main(int argc, char **argv)
{
    ThreadFunc func;

    ScopeThread t1(move(thread(&ThreadFunc::operator(), &func)));

    for (int i = 0; i < 10; i++)
    {
        cout << "main thread : " << i << endl;
        this_thread::sleep_for(chrono::seconds(1));
    }

    return 0;
}
```

ScopeThread类没有手动设置join，那么当主线程结束它会怎么样呢
```cpp
class ScopeThread
{
public:
    explicit ScopeThread(thread t) : t_(move(t))
    {
        if (!t_.joinable())
            throw logic_error("No thread");
    }

    ~ScopeThread()
    {
        t_.join();
    }

    ScopeThread(ScopeThread const &) = delete;
    ScopeThread &operator=(ScopeThread const &) = delete;

private:
    thread t_;
};

```

这里面有两点：
一个是C++构造函数初始化列表，对象成员并没有在对象构造函数体内赋值，因为对于移动或者唯一所有权对象，本身就不能复制。所以只能通过这种方式转移到类对象中。

另外一个就是在对象析构的时候，等待成员线程结束。这样就可也不再手动控制join，同时保证主线程逻辑执行完不会直接关闭进程，中断尚未完成的工作线程。

