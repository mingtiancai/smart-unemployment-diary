# 1.C++

## 1.1 基于作用域的thread管理类
```cpp
int main(int argc, char **argv)
{
    ThreadFunc func;

    ScopeThread t1(move(thread(&ThreadFunc::operator(), &func)));

    for (int i = 0; i < 10; i++)
    {
        cout << "main thread : " << i << endl;
        this_thread::sleep_for(chrono::seconds(1));
    }

    return 0;
}
```

ScopeThread类没有手动设置join，那么当主线程结束它会怎么样呢
```cpp
class ScopeThread
{
public:
    explicit ScopeThread(thread t) : t_(move(t))
    {
        if (!t_.joinable())
            throw logic_error("No thread");
    }

    ~ScopeThread()
    {
        t_.join();
    }

    ScopeThread(ScopeThread const &) = delete;
    ScopeThread &operator=(ScopeThread const &) = delete;

private:
    thread t_;
};

```

这里面有两点：
一个是C++构造函数初始化列表，对象成员并没有在对象构造函数体内赋值，因为对于移动或者唯一所有权对象，本身就不能复制。所以只能通过这种方式转移到类对象中。

另外一个就是在对象析构的时候，等待成员线程结束。这样就可也不再手动控制join，同时保证主线程逻辑执行完不会直接关闭进程，中断尚未完成的工作线程。

## 1.2 lock_guard，lock，scope_guard
在作用域内对互斥元加锁，离开作用域自动释放锁，用lock_guard,用的就是RAII实现
lock同时锁多个互斥元，切没有死锁风险
scope_guard类似于lock_guard，但是因为支持可变参数模板，可以锁多种类型互斥元

lock_gurad和lock可以配合使用，比如
```cpp
#include <iostream>
#include <thread>
#include <chrono>
#include <mutex>

using namespace std;

void swap(int &lId, int &rId)
{
    int tmpId = lId;
    lId = rId;
    rId = tmpId;
}

class X
{
private:
    int id_;
    mutex m_;

public:
    X(int id) : id_(id) {}
    friend void swap(X &lhs, X &rhs)
    {
        if (&lhs.m_ == &rhs.m_)
            return;
        lock(lhs.m_, rhs.m_);
        lock_guard<mutex> lockL(lhs.m_, std::adopt_lock);
        lock_guard<mutex> lockR(rhs.m_, std::adopt_lock);
        swap(lhs.id_, rhs.id_);
    }

    void print()
    {
        lock_guard<mutex> lock(m_);
        cout << id_ << endl;
    }
};

int main(int argc, char **argv)
{
    X x1(1);
    X x2(2);

    x1.print();
    x2.print();

    swap(x1, x2);

    x1.print();
    x2.print();

    return 0;
}
```
adopt_lock在lock_guard中，表示不用再上锁，但是在离开作用域后，会自动unlock


# 2.Sqlite源码解读

源码版本：
3.38.0

挑战一下自己，既然自己看不上两三万写业务逻辑的码农工作，既然自己想要做软件方向，想做世界级别优秀的软件工程师，那么就从一些优秀的开源项目源码解析搞起。

先学习人家，再模仿最后超越。过程很痛苦，但是一定会收获满满，而且不止需要看代码，要查阅资料，要看论文，挺好的。