# 1 C++

## 1.1 thread加载类重载成员函数
``` cpp
#include <iostream>
#include <thread>
#include <condition_variable>
#include <mutex>
#include <chrono>
#include <queue>
#include <memory>

using namespace std;

template <typename T>
class ThreadSafeQueue
{
public:
    ThreadSafeQueue()
    {
    }

    ThreadSafeQueue(ThreadSafeQueue const &other)
    {
        lock_guard<mutex> lock(other.dataMutex_);
        lock_guard<mutex> lockSelf(dataMutex_);
        dataQueue_ = other.dataQueue_;
    }

    void push(T newValue)
    {
        lock_guard<mutex> lock(dataMutex_);
        dataQueue_.push(newValue);
        cout << "push: " << newValue << endl;
        dataConditionVariable_.notify_one();
    }

    void waitAndPop(T &value)
    {
        unique_lock<mutex> lock(dataMutex_);
        dataConditionVariable_.wait(lock, [this]()
                                    { return !dataQueue_.empty(); });
        value = dataQueue_.front();
        cout << "wait pop : " << value << endl;
        dataQueue_.pop();
    }

    shared_ptr<T> waitAndPop()
    {
        unique_lock<mutex> lock(dataMutex_);
        dataConditionVariable_.wait(lock, [this]
                                    { return !dataQueue_.empty(); });
        shared_ptr<T> res(make_shared<T>(dataQueue_.front));
        dataQueue_.pop();
        return res;
    }

    bool tryPop(T &value)
    {
        lock_guard<mutex> lock(dataMutex_);
        if (dataQueue_.empty())
            return false;
        value = dataQueue_.front();
        dataQueue_.pop();
        return true;
    }

    std::shared_ptr<T> tryPop()
    {
        lock_guard<mutex> lock(dataMutex_);
        if (dataQueue_.empty())
            return nullptr;
        shared_ptr<T> res = make_shared<T>(dataQueue_.front());
        dataQueue_.pop();
        return res;
    }

    bool empty() const
    {
        lock_guard<mutex> lock(dataMutex_);
        return dataQueue_.empty();
    }

private:
    mutable mutex dataMutex_;
    queue<T> dataQueue_;
    condition_variable dataConditionVariable_;
};

int main(int argc, char **argv)
{
    ThreadSafeQueue<string> queueSample;
    queueSample.push("name1");
    queueSample.push("name2");

    string getSample1, getSample2;

    typedef void (ThreadSafeQueue<string>::*func1)(string & value);

    thread t1(&ThreadSafeQueue<string>::push, &queueSample, string("name3"));
    thread t2(func1(&ThreadSafeQueue<string>::waitAndPop), &queueSample, ref(getSample1));
    thread t3(func1(&ThreadSafeQueue<string>::waitAndPop), &queueSample, ref(getSample2));

    t1.join();
    t2.join();
    t3.join();

    cout << "getSample1: " << getSample1 << endl;
    cout << "getSample2: " << getSample2 << endl;

    return 0;
}

```

ThreadSafeQueue类定义了两个waitAndPop接口，分别是直接引用或者返回智能指针。

thread类初始化线程函数，如果是类成员函数，首先是取址类的方法，然后取址对象，后面在加入参数。

但是如果类成员函数本身又有多个重载版本，直接这么输入，thread是没有办法区分到底选择哪个函数的。类也可以是模板类
一个解决办法是使用typedef，将类成员函数重新声明一下

```cpp
typedef void (ThreadSafeQueue<string>::*func1)(string & value);

thread t2(func1(&ThreadSafeQueue<string>::waitAndPop), &queueSample, ref(getSample1));
```

## 1.2 future和async
当多线程之间存在关联，某个线程需要另外一个线程结果再运行自己相关操作的时候。

future可以搭配async一起使用
```cpp
future<int> res = async(doSomething);
```
doSomething函数返回的是int类型结果，上面的async默认是由编译器实现来管理默认行为，可以直接开启一个新线程执行，也可以延后到调用future的get方法再执行

延后到get执行：
```cpp
std::launch::defferred
```

直接起新线程执行
```cpp
std::launch::async
```

# 1.3 package_task

